<?php
/**
 * Garp_Cli_Command_Shell
 * Provide an interactive PHP shell
 *
 * @package Garp_Cli_Command
 * @author Harmen Janssen <harmen@grrr.nl>
 */
class Garp_Cli_Command_Shell extends Garp_Cli_Command {

    /**
     * Prompt symbols, appear in front of the cli.
     */
    const MULTILINE_PROMPT = ' - ';
    const SINGLE_LINE_PROMPT = '> ';

    /**
     * Result of evaluated expression.
     *
     * @var Mixed
     */
    public $__result;

    /**
     * Input (used in multi-line mode).
     * This is populated when the user submits expressions that don't end in semicolon.
     * Input is appended to this property until a semicolon is submitted.
     *
     * @var String
     */
    protected $_input = '';

    /**
     * Main starting point
     *
     * @param array $args
     * @return void
     */
    public function main(array $args = array()) {
        Garp_Cli::lineOut('Welcome to the Garp interactive shell.', Garp_Cli::YELLOW);
        Garp_Cli::lineOut('Use Ctrl-C to quit.');

        $this->_setErrorHandler();
        $this->_tick();
    }

    /**
     * Output the result of the eval'd expression
     *
     * @param string $buffer Buffered input
     * @return String
     */
    public function output($buffer) {
        if (!$buffer && !$this->__result) {
            return '';
        }

        $out = '';
        // Always include the output generated by the expression first
        if ($buffer) {
            $out .= Garp_Cli::lineOut($buffer, null, true, false);
        }

        // And follow-up with the populated result, if any
        if ($this->__result) {
            // Try to format as user-friendly as possible
            $isObjWithToArray = is_object($this->__result) &&
                method_exists($this->__result, 'toArray');
            $this->__result = $isObjWithToArray ? $this->__result->toArray() : $this->__result;
            $this->__result = var_export($this->__result, true);
            $out .= Garp_Cli::lineOut($this->__result, Garp_Cli::BLUE, true, false);
        }

        return $out;
    }

    /**
     * One iteration in the main loop.
     *
     * @return Void
     */
    protected function _tick() {
        while (true) {
            // Grab a line of PHP code from the prompt
            $line = $this->_getInput();

            /**
             * Note that $this->__result will be populated, if no target variable is given
             * in the expression. In other words, this will populate $this->__result:
             * $someModel->fetchAll();
             * But this won't:
             * $rows = $someModel->fetchAll();
             * ...because we assume the user wants to do something with the variable.
             */
            if (!$this->_input && !preg_match('/^(\$\w+\s?\=)|print|echo/', $line)) {
                $line = '$this->__result = ' . $line;
            }

            $this->_input .= $line;

            // If no semicolon is found at the end, assume
            // multi-line input. The user is therefore not finished,
            // so we just continue here and wait for that semicolon.
            if (substr($line, -1) !== ';') {
                continue;
            }

            // Execute input, and grab its output
            ob_start(array($this, 'output'));
            eval($this->_input);
            ob_end_flush();

            // Clear result var
            $this->__result = null;
            // Reset input
            $this->_input = '';
        }
    }

    /**
     * Retrieve input from the user.
     * Prefer readline because it supports history.
     *
     * @return String
     */
    protected function _getInput() {
        if (function_exists('readline') && function_exists('readline_add_history')) {
            $line = readline($this->_getPrompt());
            readline_add_history($line);
            return $line;
        }
        echo $this->_getPrompt();
        $line = Garp_Cli::prompt();
        return $line;
    }

    /**
     * Return prompt symbol.
     * In multi-line mode it's "-", otherwise "".
     *
     * @return String
     */
    protected function _getPrompt() {
        return $this->_input ? self::MULTILINE_PROMPT : self::SINGLE_LINE_PROMPT;
    }

    protected function _setErrorHandler() {
        set_error_handler(
            function ($errno, $errstr, $errfile, $errline) {
                $errTypes = array(
                E_USER_ERROR => 'Error',
                E_USER_WARNING => 'Warning',
                E_USER_NOTICE => 'Notice'
                );
                $errType = isset($errTypes[$errno]) ? $errTypes[$errno] : 'Unknown error';
                Garp_Cli::errorOut("{$errType}: {$errstr}");
                Garp_Cli::lineOut(" from {$errfile}:{$errline}", Garp_Cli::BLUE);
            }
        );
    }
}
