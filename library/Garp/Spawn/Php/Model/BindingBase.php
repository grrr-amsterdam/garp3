<?php
/**
 * Generated PHP model
 *
 * @package Garp
 * @subpackage Spawn
 * @author David Spreekmeester <david@grrr.nl>
 */
class Garp_Spawn_Php_Model_BindingBase extends Garp_Spawn_Php_Model_Abstract {
    const MODEL_DIR = '/modules/default/Model/Base/';

    protected $_behaviorsThatRequireParams = array('Weighable');

    /**
     * @var Garp_Spawn_Relation $_relation The accompanying HasAndBelongsToMany relation
     */
    protected $_relation;


    public function isOverwriteEnabled() {
        return true;
    }

    /**
     * @param Garp_Spawn_Model_Base $model      The base model this habtm model is connected to
     * @param Garp_Spawn_Relation   $habtmRelation   The accompanying HasAndBelongsToMany relation
     */
    public function __construct(Garp_Spawn_Model_Base $model, Garp_Spawn_Relation $habtmRelation) {
        parent::__construct($model);

        $this->setRelation($habtmRelation);
    }

    public function getPath() {
        $relation       = $this->getRelation();
        $bindingModel   = $relation->getBindingModel();

        return APPLICATION_PATH . self::MODEL_DIR . $bindingModel->id . '.php';
    }


    /**
     * @param   Int     $index Zero or one, indicating one or the other relation.
     * @return  Array
     */
    protected function _getSingleRelationParams($index) {
        $rel = array();

        $rel['model'] = $index
            ? $this->getModel()->id
            : $this->getRelation()->model
        ;

        $rel['alias'] = $index
            ? $this->getModel()->id
            : $this->getRelation()->name
        ;

        $rel['column'] = $this->_getRelationColumnName($rel['alias'], $index + 1);

        return $rel;
    }

    protected function _postFixAliases(array &$rels) {
        if ($nameConflicts = $this->_hasConflictingName()) {
            $rels[0]['alias'] .= '1';
            $rels[1]['alias'] .= '2';
        }
    }

    protected function _getBothRelationParams() {
        $rels = array(
            $this->_getSingleRelationParams(0),
            $this->_getSingleRelationParams(1)
        );
        $this->_postFixAliases($rels);

        $sortByAlias = function ($rel1, $rel2) {
            return strcmp($rel1['alias'], $rel2['alias']);
        };

        usort($rels, $sortByAlias);

        return $rels;
    }

    public function render() {
        $relation       = $this->getRelation();
        $bindingModel   = $relation->getBindingModel();

        $rels = $this->_getBothRelationParams();

        $table          = $this->_getBindingModelTable();
        $isHomophile    = $this->_isHomophile();

        $out = $this->_rl('<?php');
        $out.= $this->_rl('/* This file was generated by ' . get_class() . ' - do not edit */');
        $out.= $this->_rl("class Model_Base_{$bindingModel->id} extends Garp_Model_Db {");

        $out.= $this->_rl("protected \$_name = '{$table->name}';", 1, 2);

        $out.= $this->_rl(
            "protected \$_bindable = array('Model_{$rels[0]['model']}'"
            . (!$isHomophile ? ", 'Model_{$rels[1]['model']}'" : '')
            . ");", 1, 2
        );

        $out.= $this->_rl('protected $_referenceMap = array(', 1);
        $out.= $this->_rl("'{$rels[0]['alias']}' => array(", 2);
        $out.= $this->_rl("'columns' => '{$rels[0]['column']}',", 3);
        $out.= $this->_rl("'refTableClass' => 'Model_{$rels[0]['model']}',", 3);
        $out.= $this->_rl("'refColumns' => 'id'", 3);
        $out.= $this->_rl("),", 2);

        $out.= $this->_rl("'{$rels[1]['alias']}' => array(", 2);
        $out.= $this->_rl("'columns' => '{$rels[1]['column']}',", 3);
        $out.= $this->_rl("'refTableClass' => 'Model_{$rels[1]['model']}',", 3);
        $out.= $this->_rl("'refColumns' => 'id'", 3);
        $out.= $this->_rl(")", 2);
        $out.= $this->_rl(");", 1, 2);

        $out.= $this->_rl("public function init() {", 1);
        $out.= $this->_rl("parent::init();", 2);

        if ($relation->weighable) {
            $out .= $this->_renderWeighableScript();
        }

        $out.= $this->_rl("}", 1);

        $out.= $this->_rl("}", 0);

        return $out;
    }

    /**
     * @return Garp_Spawn_Relation
     */
    public function getRelation() {
        return $this->_relation;
    }

    /**
     * @param Garp_Spawn_Relation $relation
     *
     * @return void
     */
    public function setRelation($relation) {
        $this->_relation = $relation;
    }

    protected function _renderWeighableScript() {
        $thisModelId    = $this->getModel()->id;
        $thatModelId    = $this->_getRemoteModelId();

        $weightColumn1  = $this->_getWeightColumnName($thisModelId, $thatModelId, 1);
        $weightColumn2  = $this->_getWeightColumnName($thatModelId, $thisModelId, 2);

        $modelColumn1   = $this->_getRelationColumnName($thisModelId, 1);
        $modelColumn2   = $this->_getRelationColumnName($thatModelId, 2);

        $thisPostFix    = $this->_getModelPostFix($thisModelId, 1);
        $thatPostFix    = $this->_getModelPostFix($thatModelId, 2);

        $out = "\n"
            . $this->_rl("\$this->registerObserver(new Garp_Model_Behavior_Weighable(array(", 2)
            . $this->_rl("'{$thisModelId}{$thisPostFix}' => array(", 3)
            . $this->_rl("'foreignKeyColumn' => '{$modelColumn1}',", 4)
            . $this->_rl("'weightColumn' => '{$weightColumn1}'", 4)
            . $this->_rl("),", 3)
            . $this->_rl("'{$thatModelId}{$thatPostFix}' => array(", 3)
            . $this->_rl("'foreignKeyColumn' => '{$modelColumn2}',", 4)
            . $this->_rl("'weightColumn' => '{$weightColumn2}'", 4)
            . $this->_rl(")", 3)
            . $this->_rl(")));", 2, 1);

        return $out;
    }

    protected function _getRelationColumnName($modelId, $iterator) {
        $postfix        = $this->_getModelPostFix($modelId, $iterator);
        $column         = Garp_Spawn_Relation_Set::getRelationColumn($modelId, $postfix);

        return $column;
    }

    protected function _getWeightColumnName($thisModelId, $thatModelId, $iterator) {
        $thisNamespace  = $this->_getModelNamespace($thisModelId);
        $thatNamespace  = $this->_getModelNamespace($thatModelId);

        $thisPostFix    = $this->_getModelPostFix($thisModelId, $iterator === 1 ? 1 : 2);
        $thatPostFix    = $this->_getModelPostFix($thatModelId, $iterator === 1 ? 2 : 1);

        $combinedColumn = "{$thisNamespace}{$thisPostFix}_{$thatNamespace}{$thatPostFix}_weight";

        return $combinedColumn;
    }

    /**
     * @param String $modelId   Model identifier
     * @return  String  The model namespace, to be used in front of a column name, i.e. blog_post
     */
    protected function _getModelNamespace($modelId) {
        $modelNamespace = Garp_Spawn_Util::camelcased2underscored($modelId);
        return $modelNamespace;
    }

    /**
     * @param String $modelId   Model identifier
     * @param Integer $iterator
     * @return String   In case of a similar named relation, returns '1' for the base model,
     * and '2' for the remote model.
     */
    protected function _getModelPostFix($modelId, $iterator) {
        if (!$this->_hasConflictingName()) {
            return;
        }

        return $iterator;
    }

    protected function _getBindingModelTable() {
        $bindingModel   = $this->getRelation()->getBindingModel();
        $tableFactory   = new Garp_Spawn_Db_Table_Factory($bindingModel);
        $table          = $tableFactory->produceConfigTable();

        return $table;
    }

    protected function _getRemoteModelId() {
        $relation       = $this->getRelation();
        $remoteModelId  = $relation->model;

        return $remoteModelId;
    }

    protected function _isHomophile() {
        $model          = $this->getModel();
        $remoteModelId  = $this->_getRemoteModelId();
        $isHomophile    = $model->id === $remoteModelId;

        return $isHomophile;
    }

    /**
     * Whether this model's name is the same as the relation name to the other model (f.i. UserUser)
     *
     * @return Boolean
     */
    protected function _hasConflictingName() {
        $relation       = $this->getRelation();
        $model          = $this->getModel();
        // $remoteModelId   = $this->_getRemoteModelId();
        $nameConflicts  = $model->id === $relation->name;

        return $nameConflicts;
    }
}
