<?php
/**
 * Garp_Util_AssetUrl
 * class description
 *
 * @package Garp_Util
 * @author  Harmen Janssen <harmen@grrr.nl>
 * @author  David Spreekmeester <david@grrr.nl>
 */
class Garp_Util_AssetUrl {
    /**
     * Statically stored rev-manifest json file
     *
     * @var array
     */
    protected static $_revManifest = null;

    protected $_url;

    /**
     * Create a versioned URL to a file
     *
     * @param string $file The file path
     * @param string $forced_extension Force to use an extension, even when extension
     *                                 doesn't match or is missing
     *                                 (eg. '/' in 'ASSET_URL' when using a cdn,
     *                                 but 'js' is 'local')
     * @return void
     */
    public function __construct($file = null, $forced_extension = false) {
        $config = Zend_Registry::get('config');
        $baseUrl = $config->cdn->baseUrl;
        if (!$file) {
            $this->_url = $baseUrl;
            return;
        }

        // If using manifest, gulp-rev is used to generate versioned filenames.
        // Look 'em up in the manifest file
        if ($config->cdn->useRevManifest) {
            $file = $this->_processRevManifest($file);
            // If only basename is given, we assume "modern" approach.
            // AssetUrl will:
            // - prepend assets.<extension>.root to the file
            // - add the current version to the path
        } else if (strpos($file, '/') === false) {
            $file = $this->getVersionedBuildPath($file);

            // Else we will use the old (but actually more "modern") approach.
            // AssetUrl will:
            // - append version as query string (main.js?v0.0.1)
        } else if (!empty($file) && substr($file, -1) !== '/') {
            $file = $this->getVersionedQuery($file);
        }

        $extension = $forced_extension ? $forced_extension : $this->_getExtension($file);
        if (!empty($config->cdn->{$extension}->location)
            && $config->cdn->{$extension}->location === 'local'
        ) {
            // Skip the baseUrl if a file is explicitly configured as local
            // (ends up as a relative "/css/base.css" path.
            $this->_url = $file;
            return;
        }

        $this->_url = rtrim($baseUrl, '/') . '/' . ltrim($file, '/');
    }

    protected function _getExtension($file) {
        if (!$file) {
            return;
        }

        // Strip appended query string
        if (false !== strpos($file, '?')) {
            $file = substr($file, 0, strpos($file, '?'));
        }

        $fileParts = explode('.', $file);
        $lastPart = $fileParts[sizeof($fileParts) - 1];

        return $lastPart;
    }

    public function getVersionedQuery($file) {
        return $file . '?' . new Garp_Version();
    }

    public function getVersionedBuildPath($file) {
        $buildConfig = 'build';
        $assetsConfig = Zend_Registry::get('config')->assets;
        if (!$assetsConfig) {
            return $file;
        }
        $assetsConfig = $assetsConfig->{$this->_getExtension($file)};
        if (empty($assetsConfig->$buildConfig)) {
            $buildConfig = 'root';
        }
        if (empty($assetsConfig->$buildConfig)) {
            return $file;
        }
        return rtrim($assetsConfig->$buildConfig, '/') .
            '/' . new Garp_Version() . '/' . $file;
    }

    protected function _processRevManifest($file) {
        // If argument is the root and not a file, return early
        if ($file === '/' || !$file) {
            return $file;
        }

        $base = basename($file);
        $manifest = $this->getRevManifest();
        if (!$manifest) {
            throw new Exception('There is no manifest file for environment ' . APPLICATION_ENV);
        }

        if (array_key_exists($base, $manifest)) {
            $base = $manifest[$base];
        }
        return dirname($file) . DIRECTORY_SEPARATOR . $base;
    }

    /**
     * Read rev-manifest file, generated by a process like gulp-rev.
     * It maps original filenames to hashes ones.
     * Note that it is cached statically to be saved during the runtime of the script.
     *
     * @return string
     */
    public function getRevManifest() {
        if (is_null(self::$_revManifest)) {
            $manifestPath = APPLICATION_PATH . '/../rev-manifest-' . APPLICATION_ENV . '.json';
            self::$_revManifest = file_exists($manifestPath) ?
                json_decode(file_get_contents($manifestPath), true) :
                array();
        }
        return self::$_revManifest;
    }

    public function __toString() {
        return is_null($this->_url) ? '' : $this->_url;
    }
}
